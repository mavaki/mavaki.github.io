<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://mavaki.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://mavaki.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-06T21:54:48+00:00</updated><id>https://mavaki.github.io/feed.xml</id><title type="html">blank</title><subtitle>my hacking showcase </subtitle><entry><title type="html">reading 05: programming languages</title><link href="https://mavaki.github.io/blog/2024/hackers-05/" rel="alternate" type="text/html" title="reading 05: programming languages"/><published>2024-10-06T21:45:00+00:00</published><updated>2024-10-06T21:45:00+00:00</updated><id>https://mavaki.github.io/blog/2024/hackers-05</id><content type="html" xml:base="https://mavaki.github.io/blog/2024/hackers-05/"><![CDATA[<p>Programming languages require different approaches based on how they represent, change, and store data. I guess the first time I really thought differently about programming languages was when I learned Scheme for Programming Paradigms. The parentheses were strange, but the language allowed me to truly grasp recursion. One of the Scheme patterns that Prof. McMillan instilled in us was “process the car, recurse on the cdr.” After a while of using that pattern, things start to click, and the world of Scheme opened up before my eyes. The recursion mindset became natural unlike the recursion I had done in C for Fundamentals of Computing. I wasn’t surprised when I came across this quote from Paul Graham:</p> <blockquote> <p>“So how much shorter are your programs if you write them in Lisp? Most of the numbers I’ve heard for Lisp versus C, for example, have been around 7-10x.”</p> </blockquote> <p>I hadn’t really considered languages being “better” than others before. I thought it came down to personal preference, being interpreted or compiled, and some metrics like speed. But if it’s really true that Lisp is 7-10x faster than C, then it would seem obvious that Lisp is a more powerful language, especially considering that the 200,000-line Common Lisp core of ITA’s application “humiliates [Travelocity and Expedia] technologically.” I certainly thought Scheme was neat, but I didn’t really think about how concise or powerful it was. I’m interested in venturing back to it now after reading Paul Graham’s opinions on the matter.</p> <p>But what is it that makes Lisp/Scheme “simply the most powerful language available”? And what’s lacking in our current languages? Paul Graham claims that macros make Lisp very unique, almost free from syntax in a sense. The way he describes it makes Lisp seem like Linux, devoid of the gross features of Microsoft that restrict your hacking freedom. Perhaps, though, languages aren’t lacking features so much as programmers are lacking time. Paul Graham even says that he “doesn’t expect to convince anyone (over 25) to go out and learn Lisp” (p. 178). Programmers get comfortable with one language that their company expects them to use, and they don’t have the resources to learn more powerful languages that could get the job done better.</p> <p>I imagine that Python, C, and Lisp will all persist far into the future. They essentially hit all three levels of programming, with Python being the easiest and Lisp being the most challenging. While you can learn Python from just about any book or website, it seems like Lisp requires your brain to change habits. I think that the nerds who appreciate Lisp will probably ensure it never dies out, whereas Python could more easily be replaced by something else simple and intuitive. I hope more mind-streching languages arise to give hackers the edge in their startups. Or maybe Lisp can already do that for them.</p>]]></content><author><name></name></author><category term="hackers"/><category term="ethics"/><summary type="html"><![CDATA[the future of computer science]]></summary></entry><entry><title type="html">reading 05: programming languages</title><link href="https://mavaki.github.io/blog/2024/hackers-05/" rel="alternate" type="text/html" title="reading 05: programming languages"/><published>2024-10-05T17:15:00+00:00</published><updated>2024-10-05T17:15:00+00:00</updated><id>https://mavaki.github.io/blog/2024/hackers-05</id><content type="html" xml:base="https://mavaki.github.io/blog/2024/hackers-05/"><![CDATA[<p>Programming languages require different approaches based on how they represent, change, and store data. I guess the first time I really thought differently about programming languages was when I learned Scheme for Programming Paradigms. The parentheses were strange, but the language allowed me to truly grasp recursion. One of the Scheme patterns that Prof. McMillan instilled in us was “process the car, recurse on the cdr.” After a while of using that pattern, things start to click, and the world of Scheme opened up before my eyes. The recursion mindset became natural unlike the recursion I had done in C for Fundamentals of Computing. I wasn’t surprised when I came across this quote from Paul Graham:</p> <blockquote> <p>“So how much shorter are your programs if you write them in Lisp? Most of the numbers I’ve heard for Lisp versus C, for example, have been around 7-10x.”</p> </blockquote> <p>I hadn’t really considered languages being “better” than others before. I thought it came down to personal preference, being interpreted or compiled, and some metrics like speed. But if it’s really true that Lisp is 7-10x faster than C, then it would seem obvious that Lisp is a more powerful language, especially considering that the 200,000-line Common Lisp core of ITA’s application “humiliates [Travelocity and Expedia] technologically.” I certainly thought Scheme was neat, but I didn’t really think about how concise or powerful it was. I’m interested in venturing back to it now after reading Paul Graham’s opinions on the matter.</p> <p>But what is it that makes Lisp/Scheme “simply the most powerful language available”? And what’s lacking in our current languages? Paul Graham claims that macros make Lisp very unique, almost free from syntax in a sense. The way he describes it makes Lisp seem like Linux, devoid of the gross features of Microsoft that restrict your hacking freedom. Perhaps, though, languages aren’t lacking features so much as programmers are lacking time. Paul Graham even says that he “doesn’t expect to convince anyone (over 25) to go out and learn Lisp” (p. 178). Programmers get comfortable with one language that their company expects them to use, and they don’t have the resources to learn more powerful languages that could get the job done better.</p> <p>I imagine that Python, C, and Lisp will all persist far into the future. They essentially hit all three levels of programming, with Python being the easiest and Lisp being the most challenging. While you can learn Python from just about any book or website, it seems like Lisp requires your brain to change habits. I think that the nerds who appreciate Lisp will probably ensure it never dies out, whereas Python could more easily be replaced by something else simple and intuitive. I hope more mind-streching languages arise to give hackers the edge in their startups. Or maybe Lisp can already do that for them.</p>]]></content><author><name></name></author><category term="hackers"/><category term="ethics"/><summary type="html"><![CDATA[the future of computer science]]></summary></entry><entry><title type="html">reading 04: painting code</title><link href="https://mavaki.github.io/blog/2024/hackers-04/" rel="alternate" type="text/html" title="reading 04: painting code"/><published>2024-09-18T05:45:00+00:00</published><updated>2024-09-18T05:45:00+00:00</updated><id>https://mavaki.github.io/blog/2024/hackers-04</id><content type="html" xml:base="https://mavaki.github.io/blog/2024/hackers-04/"><![CDATA[<p>I found <i>Chapter 1: Why Nerds Are Unpopular</i> interesting because popularity didn’t seem to be as big of a deal in my elementary and middle schools. In my elementary school, each grade was divided into classrooms with roughly 25 students, and each classroom had two tables for lunch. Naturally, the girls sat at one of the tables and the guys sat at the other. I felt that, while some students were more popular than others, most students had their group of friends and didn’t necessarily want to be friends with the popular ones. Perhaps, the only time popularity really seemed to be relevant to me was when I entered middle school at small, all-boys Catholic school where I didn’t know anybody. I just wanted to make friends in general, and the popular kids seemed to be pretty good at befriending one another. But, eventually, I met all 46 guys in my class and found a group that I liked. So my experience is pretty different than the one that Paul Graham describes. However, I was interested in his reasoning for why the real world is more hospitable to nerds:</p> <blockquote> <p>I think the important thing about the real world is not that it’s populated by adults, but that it’s very large, and the things you do have real effects. (Hackers &amp; Painters, ch. 1)</p> </blockquote> <p>This is a reasonable claim, although nowadays I feel as though smartphones have supressed certain bad behaviors because there have been numerous instances of people saying or doing something and having to face the consequences. It’s unfortunate that people have lost their jobs over one bad decision, but somehow I think that the overall smartphone culture has given a little more power back to the nerds. And the advances in technology allow nerds (at least, computer scientists) to spend limitless time learning from the hands-on computer experience. The following quote summarizes this sentiment well:</p> <blockquote> <p>In hacking, like painting, work comes in cycles. Sometimes you get excited about a new project and you want to work sixteen hours a day on it. Other times nothing seems interesting. (Hackers &amp; Painters, ch. 2)</p> </blockquote> <p>I sometimes worry about not being passionate about work in my future job. I’ve definitely been in situations where I uttely lack an interest in the problem (aka Logic Design). On the other hand, there are projects where I would prefer to work on them than do anything else. I think there’s a certain threshold at which work becomes bearable, and anything under this threshold just won’t get my full enthusiasm and effort. Recently, I’ve enjoyed working on our spreadsheet project for Distributed Systems, and I often push off work for my other classes to write and bum code for it. Graham’s parallel between painting and hacking ran true for this project:</p> <blockquote> <p>Paintings usually begin with a sketch … [But] sometimes the original plans turn out to be mistaken. Countless paintings, when you look at them in x-rays, turn out to have limbs that have been moved or facial features that have been readjusted. (Hackers &amp; Painters, ch. 2)</p> </blockquote> <p>I especially liked this because I visited the National Gallery of Ireland over the summer, and we got to see one painting with some of its sketches next to it. There were a lot of minor changes that went into the full product, and that’s not something you usually get to see. I suppose GitHub has affored hackers the luxury of seeing their work change, but it’s a bit better to see visually with a painting.</p> <p>Ultimately, I think Paul Graham’s version of a hacker is compatible with Steven Levy’s. I hadn’t considered before that hackers are “the essence of Americanness,” but I agree. The story of Ring, the video doorbell system, as a little hack-turned-startup definitely has an American feel. I’m proud to be an Amer–I mean, hacker.</p>]]></content><author><name></name></author><category term="hackers"/><category term="ethics"/><summary type="html"><![CDATA[an inquiry into popularity and nerds]]></summary></entry><entry><title type="html">reading 02: profit hacking</title><link href="https://mavaki.github.io/blog/2024/hackers-02/" rel="alternate" type="text/html" title="reading 02: profit hacking"/><published>2024-09-08T03:59:00+00:00</published><updated>2024-09-08T03:59:00+00:00</updated><id>https://mavaki.github.io/blog/2024/hackers-02</id><content type="html" xml:base="https://mavaki.github.io/blog/2024/hackers-02/"><![CDATA[<p>The “True Hackers” and the “Hardware Hackers” were similar in their devotion to computers, but Lee Felsenstein felt that the MIT veterans simply “were not as interested in getting computer technology out to the people as they were in elegant, mind-blowing computer pyrotechnics” (Levy ch. 9). The True Hackers would all share the same basic routine, from poor sleep schedules to computer programs and everything in-between. The Hardware Hackers, however, were more dispersed: they were like tinkerers who convened every couple of weeks to share their recent discoveries and learn from those of the others. And it seems to me as though they had a much greater impact in the world of technology given their desire to spread it.</p> <p>Even before the first personal computer was sold, the Hardware Hackers desired to bring the power of the computer to the individual, which is apparent through Community Memory. They set up costly communal computers that were typically reserved for wealthy institutions, and they made it available for the public to personally discover the power and beauty of computing. When Ed Roberts later released the first computer for the masses, the Hackers worked to create plug-ins that actually made it useful. And this later led to all-in-one computers that were for the consumer, especially through the vision of Steve Jobs and the other planners of Apple.</p> <p>I think that a major turning point in the development of the computer had to do with Bill Gates’s coding of Altair BASIC and his subsequent “An Open Letter to Hobbyists.” Gates wrote the article as a result of people copying his Altair BASIC software without paying for it, and it was the first instance that Levy mentions of someone selling software. But this letter and its underlying story irk me in a few ways. First, I think that Bill Gates and his team share part of the responsibility for the stolen software. If you plan on selling a product that can be easily replicated, why would you ever let someone get their hands on it? It seems reasonable to assume that one should take basic precautionary measures to prevent people from stealing his or her software (in the form of paper tapes) if one plans on selling them. The story is not entirely clear on <i>how</i> the paper tape was stolen, but I believe that Bill Gates should have been more aware: The Hardware Hackers who stole his software were accustomed to helping one another and sharing ideas and products amongst themselves for the sake of improvement and sheer fascination. Second, Bill Gates was charging a pretty penny for his software: “$30 for the 4K version, $35 for the 8K version, and $60 for the expanded version” (Wikipedia). That is the equivalent of roughly $175, $205, and $290, respectively, in 2024. I, for one, would probably not pay that for any software. It is true, however, that nowadays there is almost always a free and open-source alternative to a given propriertary application. But even in the 1970s, Tom Pittman felt the same way, and he showed that people <i>were</i> willing to buy software when the price wasn’t as egregious as Gates’s BASIC by selling a 6800 Tiny BASIC interpreter for only five dollars. Third, I think Gates thought too highly of his own software, deeming it to be the remedy to all of the world’s problems. However, I think that part of the reason his software was stolen by so many was because it was right there: someone showed up at a Homebrew meeting with exactly what the hackers wanted, so why would they decline the offer? Levy even indicates that Homebrew members were perfectly capable of writing their own BASIC interpreters, and some did. But when there is an easy solution to a time-consuming project sitting right in front of you for free, I don’t think that many thought too hard about it–they just took it and progressed onto other projects.</p> <p>This is just one instance (and coincidentally one of the first) of the Hacker Ethic becoming compromised. Bill Gates did not want information to be free like the hackers did, and neither did other sprouting companies who were seeking financial success. I really struggle to determine whether or not I think that compromising the ideals of the Hacker Ethic is worth having a larger impact on the world. I don’t know what the world would look like today if the Hacker Ethic had been upheld all of these years. But I want to say that the Hacker Ethic is worth upholding, especially in light of the open-source community and what it has produced. Maybe, however, the Hacker Ethic is too idealistic, almost like Utopia, which is not possible in a world of imperfect human beings.</p>]]></content><author><name></name></author><category term="hackers"/><category term="ethics"/><summary type="html"><![CDATA[the rise of the "Hardware Hackers"]]></summary></entry><entry><title type="html">reading 01: to hack or not to hack</title><link href="https://mavaki.github.io/blog/2024/hackers-01/" rel="alternate" type="text/html" title="reading 01: to hack or not to hack"/><published>2024-08-31T00:15:00+00:00</published><updated>2024-08-31T00:15:00+00:00</updated><id>https://mavaki.github.io/blog/2024/hackers-01</id><content type="html" xml:base="https://mavaki.github.io/blog/2024/hackers-01/"><![CDATA[<p>Steven Levy presents the “true hacker” as an artist of sorts: he sees immense beauty in the computer, believing that computers are the universal medium through which humans can express themselves. He is constantly using and imitating the works of his fellow artists to create new works, which does not upset the other artists in the slightest. On the contrary, these artists are overjoyed when their art is considered so beautiful that it elicits imitation. One could even say that imitation is something that these artists strive for–to create a masterpiece that others admire and use as a basis for future art.</p> <p>It is interesting to note that many true hackers become so involved in hacking that they neglect to have a regular schedule for anything else, such as showering or sleeping. Instead, they delay such things to the infinitesimal degree, until these actions are no longer deemed a choice but a necessity. However, I think that this frequent trait amongst hackers actually points to a deeper quality that is shared by all true hackers: comptetitiveness. They all seek to create the <i>best</i> programs, more for the sake of the art itself than for anything else. This idea is well illustrated by the bumming of the decimal print routine:</p> <blockquote> <p>“More than a competition, the ultimate bumming of the decimal print routine became a sort of hacker Holy Grail. … People would work for hours, seeking a way to do the same thing in fewer lines of code. It became more than a competition; it was a quest.” (Levy, ch. 2)</p> </blockquote> <p>The competitive nature of these true hackers, especially when paired with their unlimited access to scarce computers, fostered an environment that was not unlike that of the Renaissance. The hackers developed different works of art in the form of hardware and software, occasionally spurred on by an idea from a professor, a contest with a cash prize, or the thrill of setting a new record. For example, Stewart Nelson designed an interface between a computer and a disk drive at the prompting of Ed Fredkin; Peter Samson schemed The Great Subway Hack to break a Harvard student’s record for traveling to every stop on the New York subway system; and Bill Gosper created the first glider gun in LIFE, receiving the fifty dollar prize offered by John Conway. These pursuits are essentially the modern reincarnation of those during the Renaissance, such as Ghiberti’s masterpiece that won the competition to create the <a href="https://en.wikipedia.org/wiki/North_Doors_of_the_Florence_Baptistery">North Doors of the Florence Baptistery</a>. The only difference is that these hackers created art that opened the doors of the world to a completely new reality.</p> <p>Before picking up Levy’s book, I viewed hackers as the computer enthusiasts who nosed around in places that they shouldn’t. They might pull pranks, such as gaining access to their principal’s email account and informing parents that school would be cancelled the following day. Or they might break into a company’s computer system and lock access until a ransom is paid. In that sense, I admired hackers for discovering ways to bypass a security system, but I wasn’t exactly interested in becoming one myself due to potential disciplinary consequences.</p> <p>But it is now clear to me that the concept of a “true hacker” is quite different than this notion of a hacker. True hackers are tinkerers and creators, hacking “for the sake of having something which [is] in its metaphorical way alive” (Levy, ch. 2). I am inspired by them because they want to change humanity for the better, and they will accept anyone who can help them to further this goal. I aspire to be a true hacker myself because I know how much I have benefited from their endeavors, and it would be great to create hacks for the common good like they have.</p>]]></content><author><name></name></author><category term="hackers"/><category term="ethics"/><summary type="html"><![CDATA[the idea of a hacker]]></summary></entry><entry><title type="html">third-party development boards in Arduino IDE</title><link href="https://mavaki.github.io/blog/2024/development-boards/" rel="alternate" type="text/html" title="third-party development boards in Arduino IDE"/><published>2024-06-21T20:25:00+00:00</published><updated>2024-06-21T20:25:00+00:00</updated><id>https://mavaki.github.io/blog/2024/development-boards</id><content type="html" xml:base="https://mavaki.github.io/blog/2024/development-boards/"><![CDATA[<style>#boards{border-collapse:collapse;width:100%}#boards td,#boards th{border:1px;text-align:left;padding:8px}#boards th{padding-top:12px;padding-bottom:12px;text-align:left;background-color:#676767;color:white}</style> <p>Getting started with Arduino IDE as a newbie is relatively straightforward, but it can be difficult when you’re dealing with third-party boards that don’t work out of the box. While I managed to get most of my devices working, an <code class="language-plaintext highlighter-rouge">Adafruit Bluefruit</code> kept throwing this error at me:</p> <blockquote> <p>A fatal error occurred: Failed to connect to ESP32: No serial data received.</p> </blockquote> <p>Since it was challenging to find useful resources, I decided to write this blog post about the topic. I’m going to explain how to set up some common thiry-party boards in Arduino IDE using Linux, but the same process should apply for similar boards and different operating systems.</p> <p><br/></p> <table id="boards"> <tr> <th>Board</th> <th>Package</th> <th>URL</th> </tr> <tr> <td><a href="https://www.keyestudio.com/products/keyestudio-esp32-plus-development-board-woroom-32-module-wifibluetooth-compatible-with-arduino">Keyestudio ESP32 PLUS Development Board</a></td> <td>esp32 by Espressif Systems</td> <td>https://dl.espressif.com/dl/package_esp32_index.json</td> </tr> <tr> <td><a href="https://www.seeedstudio.com/Seeed-XIAO-ESP32C3-p-5431.html">Seeed Studio XIAO ESP32C3</a></td> <td>esp32 by Espressif Systems</td> <td>https://files.seeedstudio.com/arduino/package_seeeduino_boards_index.json</td> </tr> <tr> <td><a href="https://www.adafruit.com/product/2821">Adafruit Feather HUZZAH with ESP8266</a></td> <td>esp8266 by ESP8266 Community</td> <td>http://arduino.esp8266.com/stable/package_esp8266com_index.json</td> </tr> <tr> <td><a href="https://www.digikey.ie/en/products/detail/adafruit-industries-llc/3406/7034992">Adafruit Feather nRF52 Bluefruit LE</a></td> <td>Adafruit nRF52 by Adafruit</td> <td>https://adafruit.github.io/arduino-board-index/package_adafruit_index.json</td> </tr> </table> <p><br/></p> <p>In the <code class="language-plaintext highlighter-rouge">Board</code> column you will find the name of each board hyperlinked to the manufacturer’s site. (Note that this is not the same URL that is included in the <code class="language-plaintext highlighter-rouge">URL</code> column.) Once you have identified your board, you will need to open Arduino IDE and navigate to the <code class="language-plaintext highlighter-rouge">Boards Manager</code> (<code class="language-plaintext highlighter-rouge">Tools</code> &gt; <code class="language-plaintext highlighter-rouge">Board</code> &gt; <code class="language-plaintext highlighter-rouge">Boards Manager</code>). Then you can search for the appropriate package (listed in the <code class="language-plaintext highlighter-rouge">Package</code> column) for your board. Click <code class="language-plaintext highlighter-rouge">Install</code> and wait until the installation is complete. Finally, copy the corresponding URL from the <code class="language-plaintext highlighter-rouge">URL</code> column and open the <code class="language-plaintext highlighter-rouge">Preferences</code> menu (<code class="language-plaintext highlighter-rouge">File</code> &gt; <code class="language-plaintext highlighter-rouge">Preferences</code>), where you can paste the URL under <code class="language-plaintext highlighter-rouge">Additional boards manager URLs</code>. (This is a platform index URL that allows users to install and update platforms that are not included in the official package list.) Now you should be all set to select your device and begin programming, which I describe below.</p> <p>If you’re working with an original nRF52832 device like the <code class="language-plaintext highlighter-rouge">Adafruit Feather nRF52 Bluefruit LE</code>, you will likely need to update the bootloader. If you’re using <i>Linux</i>, you will first need to install the <code class="language-plaintext highlighter-rouge">adafruit-nrfutil</code> package. The <a href="https://aur.archlinux.org/packages/python-adafruit-nrfutil">python-adafruit-nrfutil</a> package on the AUR worked for me, but there are also instructions on <a href="https://aur.archlinux.org/packages/python-adafruit-nrfutil">Adafruit</a> for other distributions. I was then able to select <code class="language-plaintext highlighter-rouge">Tools</code> &gt; <code class="language-plaintext highlighter-rouge">Burn Bootloader</code>, which flashed my <code class="language-plaintext highlighter-rouge">Adafruit nRF52</code> and got everything running smoothly. If you experience any issues, you can refer to <a href="https://learn.adafruit.com/bluefruit-nrf52-feather-learning-guide/updating-the-bootloader">Adafruit</a>.</p> <p><br/></p> <table id="boards"> <tr> <th>Group</th> <th>Entry</th> <th>Port</th> </tr> <tr> <td>esp32</td> <td>ESP32-WROOM-DA Module</td> <td>/dev/ttyUSB0</td> </tr> <tr> <td>esp32</td> <td>XIAO_ESP32C3</td> <td>/dev/ttyACM0</td> </tr> <tr> <td>esp8266</td> <td>Adafruit Feather HUZZAH ESP8266</td> <td>/dev/ttyUSB0</td> </tr> <tr> <td>Adafruit nRF52</td> <td>Adafruit Feather nRF52832</td> <td>/dev/ttyUSB0</td> </tr> </table> <p><br/></p> <p>This table lists the information that you will need to select your board in Arduino IDE, and I’ve also included the port that I used (although yours might be different). Open <code class="language-plaintext highlighter-rouge">Tools</code> and hover over the <code class="language-plaintext highlighter-rouge">Board</code> option, where you will see the different packages that you have installed. Then refer to the <code class="language-plaintext highlighter-rouge">Group</code> and <code class="language-plaintext highlighter-rouge">Entry</code> columns to select your board. If your device is plugged in, the port should have been selected automatically, but you can also select it manually under <code class="language-plaintext highlighter-rouge">Tools</code> &gt; <code class="language-plaintext highlighter-rouge">Port</code>.</p> <p>At this point, you should be all set to get your board blinking ;) If you have any questions, feel free to leave a comment below.</p>]]></content><author><name></name></author><category term="arduino"/><category term="linux,"/><category term="research"/><summary type="html"><![CDATA[a hassel-free guide for setting up Arduino alternatives]]></summary></entry></feed>